"use strict";(self.webpackChunkfrontend_dairy=self.webpackChunkfrontend_dairy||[]).push([[425],{3905:(t,e,n)=>{n.d(e,{Zo:()=>m,kt:()=>h});var r=n(7294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,r,i=function(t,e){if(null==t)return{};var n,r,i={},a=Object.keys(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var l=r.createContext({}),u=function(t){var e=r.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},m=function(t){var e=u(t.components);return r.createElement(l.Provider,{value:e},t.children)},c="mdxType",g={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(t,e){var n=t.components,i=t.mdxType,a=t.originalType,l=t.parentName,m=s(t,["components","mdxType","originalType","parentName"]),c=u(n),d=i,h=c["".concat(l,".").concat(d)]||c[d]||g[d]||a;return n?r.createElement(h,o(o({ref:e},m),{},{components:n})):r.createElement(h,o({ref:e},m))}));function h(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s[c]="string"==typeof t?t:i,o[1]=s;for(var u=2;u<a;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9730:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var r=n(7462),i=(n(7294),n(3905));const a={id:"alg-sorting-linear",slug:"/algorithms/sorting/linear",title:"Linear Sorting Algorithms",sidebar_label:"Linear",sidebar_position:3},o="Linear Sorting Algorithms",s={unversionedId:"algorithms/sorting/alg-sorting-linear",id:"algorithms/sorting/alg-sorting-linear",title:"Linear Sorting Algorithms",description:"Introduction",source:"@site/docs/algorithms/sorting/Linear.md",sourceDirName:"algorithms/sorting",slug:"/algorithms/sorting/linear",permalink:"/docs/algorithms/sorting/linear",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"alg-sorting-linear",slug:"/algorithms/sorting/linear",title:"Linear Sorting Algorithms",sidebar_label:"Linear",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"O(nlogn)",permalink:"/docs/algorithms/sorting/onlogn"},next:{title:"Tutorials",permalink:"/docs/category/tutorials"}},l={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Comparison",id:"comparison",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Bucket Sort",id:"bucket-sort",level:3},{value:"Counting Sort",id:"counting-sort",level:3},{value:"Radix Sort",id:"radix-sort",level:3},{value:"Conclusion",id:"conclusion",level:2}],m={toc:u},c="wrapper";function g(t){let{components:e,...a}=t;return(0,i.kt)(c,(0,r.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"linear-sorting-algorithms"},"Linear Sorting Algorithms"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Bucket Sort: divide the input into buckets and sort each bucket individually, or recursively sort each bucket, and then merge the buckets in sorted order, or use a bucket data structure that supports efficient merging (e.g. a priority queue)"),(0,i.kt)("li",{parentName:"ul"},"Counting Sort: counting the number of occurrences of each value, and using those counts to compute an array of the number of values smaller than each value, and then using that information to place the values in order"),(0,i.kt)("li",{parentName:"ul"},"Radix Sort: sorting by individual digits, starting at the least significant digit, using any stable sorting algorithm for the digit sort")),(0,i.kt)("h2",{id:"comparison"},"Comparison"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Algorithm"),(0,i.kt)("th",{parentName:"tr",align:null},"Best"),(0,i.kt)("th",{parentName:"tr",align:null},"Average"),(0,i.kt)("th",{parentName:"tr",align:null},"Worst"),(0,i.kt)("th",{parentName:"tr",align:null},"Space"),(0,i.kt)("th",{parentName:"tr",align:null},"Stable ?"),(0,i.kt)("th",{parentName:"tr",align:null},"In-Place ?"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Bucket Sort"),(0,i.kt)("td",{parentName:"tr",align:null},"O(n+k)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(n+k)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(n^2)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"No")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Counting Sort"),(0,i.kt)("td",{parentName:"tr",align:null},"O(n+k)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(n+k)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(n+k)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(k)"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"No")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Radix Sort"),(0,i.kt)("td",{parentName:"tr",align:null},"O(nk)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(nk)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(nk)"),(0,i.kt)("td",{parentName:"tr",align:null},"O(n+k)"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"No")))),(0,i.kt)("h2",{id:"implementation"},"Implementation"),(0,i.kt)("h3",{id:"bucket-sort"},"Bucket Sort"),(0,i.kt)("p",null,"Bucket Sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the most to least significant digit flavour. Bucket sort is a generalization of pigeonhole sort. Bucket sort can be implemented with comparisons and therefore can also be considered a comparison sort algorithm. The computational complexity estimates involve the number of buckets."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Bucket Sort",src:n(8653).Z,width:"300",height:"126"})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Bucket Sort" showLineNumbers',title:'"Bucket','Sort"':!0,showLineNumbers:!0},"/**\n * Bucket Sort Implementation\n * \n * Bucket sort is a comparison sort algorithm that operates on elements by\n * dividing them into different buckets and then sorting these buckets\n * individually. Each bucket is sorted individually using a separate sorting\n * algorithm or by applying the bucket sort algorithm recursively. Bucket sort\n * is mainly useful when the input is uniformly distributed over a range.\n * \n * @see https://en.wikipedia.org/wiki/Bucket_sort\n * \n * Time Complexity of Solution:\n * Best Case O(n+k); Average Case O(n+k); Worst Case O(n^2),\n * \n * Space Complexity of Solution:\n * Worst Case O(n).\n\n * where n is the size of the input array and k means the values range from 0\n * \n * Stability of Solution: Yes\n * In-Place of Solution: No\n * \n * @param {number []} list the array of numbers to be sorted.\n * @param {number} size the size of the bucket, default is 5.\n * @return {number []} the sorted array in non-decreasing order.\n */\nconst bucketSort = (list, size) => {\n  if (size === undefined) {\n    size = 5;\n  }\n  if (list.length <= 1) {\n    return list;\n  }\n\n  const min = Math.min(...list);\n  const max = Math.max(...list);\n\n  const bucketCount = Math.floor((max - min) / size) + 1;\n  const buckets = new Array(bucketCount).fill().map(() => []);\n  for (let i = 0; i < list.length; i++) {\n    const key = Math.floor((list[i] - min) / size);\n    buckets[key].push(list[i]);\n  }\n\n  let sortedList = [];\n  for (let i = 0; i < buckets.length; i++) {\n    const sortedBucket = buckets[i].sort((a, b) => a - b);\n    sortedList = sortedList.concat(sortedBucket);\n  }\n\n  return sortedList;\n}\n\nexport default bucketSort;\n")),(0,i.kt)("h3",{id:"counting-sort"},"Counting Sort"),(0,i.kt)("p",null,"Counting"),(0,i.kt)("p",null,"Counting Sort is a sorting algorithm that sorts the elements of an array by counting the number of occurrences of each unique element in the array. The count is stored in an auxiliary array and the sorting is done by mapping the count as an index of the auxiliary array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Counting Sort" showLineNumbers',title:'"Counting','Sort"':!0,showLineNumbers:!0},"/**\n * Counting Sort Implementation\n * \n * Counting sort is a sorting technique based on keys between a specific range.\n * It works by counting the number of objects having distinct key values (kind\n * of hashing). Then doing some arithmetic to calculate the position of each\n * object in the output sequence.\n * \n * @see https://en.wikipedia.org/wiki/Counting_sort\n * \n * Time Complexity of Solution:\n * Best Case O(n+k); Average Case O(n+k); Worst Case O(n+k),\n * \n * Space Complexity of Solution:\n * Worst Case O(n+k).\n *\n * where n is the size of the input array and k means the values range from 0\n * to k.\n * \n * Stability of Solution: Yes\n * In-Place of Solution: No\n * \n * @param {number []} nums the array of numbers to be sorted.\n * @return {number []} the sorted array in non-decreasing order.\n *\n */\n\nconst countingSort = (nums) => {\n  if (nums.length <= 1) {\n    return nums;\n  }\n\n  const min = Math.min(...nums);\n  const max = Math.max(...nums);\n\n  const count = new Array(max - min + 1).fill(0);\n\n  for (let i = 0; i < nums.length; i++) {\n    const index = nums[i] - min;\n    count[index]++;\n  }\n\n  let sortedList = [];\n  for (let i = 0; i < count.length; i++) {\n    while (count[i] > 0) {\n      sortedList.push(i + min);\n      count[i]--;\n    }\n  }\n\n  return sortedList;\n}\n\nexport default countingSort;\n")),(0,i.kt)("h3",{id:"radix-sort"},"Radix Sort"),(0,i.kt)("p",null,"Radix Sort is a sorting algorithm that sorts the elements by first grouping the individual digits of the same place value. Then, sort the elements according to their increasing/decreasing order. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Radix Sort" showLineNumbers',title:'"Radix','Sort"':!0,showLineNumbers:!0},"/**\n * Radix Sort Implementation\n * \n * Radix sort is a non-comparative integer sorting algorithm that sorts data with\n * integer keys by grouping keys by the individual digits which share the same\n * significant position and value. A positional notation is required, but because\n * integers can represent strings of characters (e.g., names or dates) and\n * specially formatted floating point numbers, radix sort is not limited to\n * integers.\n * \n * @see https://en.wikipedia.org/wiki/Radix_sort\n * \n * @ Time Complexity of Solution:\n * Best Case O(nk); Average Case O(nk); Worst Case O(nk),\n * \n * @ Space Complexity of Solution:\n * Worst Case O(n+k).\n * \n * where n is the size of the input array and k means the values range from 0\n * to k.\n * \n * Stability of Solution: Yes\n * In-Place of Solution: No\n * \n * @param {number []} items the array of numbers to be sorted.\n * @return {number []} the sorted array in non-decreasing order.\n * \n */\n\nconst radixSort = (items, RADIX) => {\n  if (items.length <= 1) {\n    return items;\n  }\n  \n  if (RADIX === undefined) {\n    RADIX = 10;\n  }\n\n  let maxLength = false;\n  let placement = 1;\n\n  while (!maxLength) {\n    maxLength = true;\n    let buckets = [];\n\n    for (let i = 0; i < RADIX; i++) {\n      buckets.push([]);\n    }\n\n    for (let i = 0; i < items.length; i++) {\n      let tmp = items[i] / placement;\n      buckets[Math.floor(tmp % RADIX)].push(items[i]);\n      if (maxLength && tmp > 0) {\n        maxLength = false;\n      }\n    }\n\n    let idx = 0;\n    for (let i = 0; i < RADIX; i++) {\n      let bucket = buckets[i];\n      for (let j = 0; j < bucket.length; j++) {\n        items[idx++] = bucket[j];\n      }\n    }\n\n    placement *= RADIX;\n  }\n\n  return items;\n}\n")),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Bucket sort, counting sort, and radix sort are sorting algorithms with distinct areas of usefulness. Bucket sort is effective when the input is uniformly distributed across a range, while counting sort excels when the input falls within a small range. Radix sort is advantageous when the input consists of elements with the same number of digits. These algorithms are not affected by the lower bound of O(n log n) imposed on comparison-based sorting algorithms since they do not rely on comparisons. However, they do require additional space as they are not in-place algorithms. Furthermore, these sorting methods are stable, ensuring the relative order of equal elements is preserved. Due to their linear time complexity, they outperform comparison-based sorting algorithms. Nonetheless, their integer-based nature makes them unsuitable for sorting floating-point numbers. Additionally, these algorithms are not adaptive, meaning they cannot leverage existing order within the input. Lastly, they are not online algorithms and cannot sort a list as it is received incrementally."))}g.isMDXComponent=!0},8653:(t,e,n)=>{n.d(e,{Z:()=>r});const r=n.p+"assets/images/Bucket_sort.svg-fa16365095ba9ff2e82884bf6e3cf2de.png"}}]);